scalar DateTime

enum SortOrder {
  ASC
  DESC
}

type Query {
  video(id: ID!): Video!
  videos(input: GetVideosInput!): VideoCollection!

  tag(id: ID!): Tag!
  tags(input: GetTagsInput!): TagCollection!

  mylist(id: ID!): Mylist!

  searchVideos(input: SearchVideoInput!): SearchVideosPayload!
  searchTags(input: SearchTagInput!): SearchTagsPayload!

  user(name: String!): User!
  whoami: User

  nicovideoVideoSource(sourceId: ID!): NicovideoVideoSource!
  findNicovideoVideoSource(sourceId: ID!): NicovideoVideoSource
}

type Mutation {
  registerTag(input: RegisterTagInput!): RegisterTagPayload!
  registerVideo(input: RegisterVideoInput!): RegisterVideoPayload!

  tagVideo(input: TagVideoInput!): TagVideoPayload!
  untagVideo(input: UntagVideoInput!): UntagVideoPayload!

  createMylist(input: CreateMylistInput!): CreateMylistPayload!

  likeVideo(input: LikeVideoInput!): LikeVideoPayload!
  undoLikeVideo(input: UndoLikeVideoInput!): UndoLikeVideoPayload!

  addVideoToMylist(input: AddVideoToMylistInput!): AddVideoToMylistPayload!
  removeVideoFromMylist(input: RemoveVideoFromMylistInput!): RemoveVideoFromMylistPayload!
}

type Video {
  id: ID!
  title: String!
  titles: [VideoTitle!]!
  thumbnailUrl: String!
  thumbnails: [VideoThumbnail!]!
  tags: [Tag!]!
  hasTag(id: ID!): Boolean!
  history(input: VideoHistoryInput!): VideoHistoryCollection!
  registeredAt: DateTime!
  similarVideos(input: VideoSimilarVideosInput!): VideoSimilarVideosPayload!

  nicovideoSources: [NicovideoVideoSource!]!
}

type VideoTitle {
  title: String!
  primary: Boolean!
}

type VideoThumbnail {
  imageUrl: String!
  primary: Boolean!
}

interface VideoSource {
  id: String!
  sourceId: String!
  url: String!
  video: Video!
}

type NicovideoVideoSource implements VideoSource {
  id: String!
  sourceId: String!
  video: Video!
  url: String!
}

type YoutubeVideoSource implements VideoSource {
  id: String!
  sourceId: String!
  video: Video!
  url: String!
}

input VideoHistoryInput {
  skip: Int = 0
  limit: Int = 10
  order: VideoHistoryOrder = { createdAt: DESC }
}

input VideoHistoryOrder {
  createdAt: SortOrder
}

type VideoHistoryCollection {
  nodes: [VideoHistoryItem!]!
}

interface VideoHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  video: Video!
}

type VideoRegisterHistoryItem implements VideoHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  video: Video!
}

type VideoAddTitleHistoryItem implements VideoHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  video: Video!
  title: String!
}

type VideoDeleteTitleHistoryItem implements VideoHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  video: Video!
  title: String!
}

type VideoChangePrimaryTitleHistoryItem implements VideoHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  video: Video!
  from: String
  to: String!
}

type VideoAddThumbnailHistoryItem implements VideoHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  video: Video!
  thumbnail: String!
}

type VideoDeleteThumbnailHistoryItem implements VideoHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  video: Video!
  thumbnail: String!
}

type VideoChangePrimaryThumbnailHistoryItem implements VideoHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  video: Video!
  from: String
  to: String!
}

type VideoAddTagHistoryItem implements VideoHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  video: Video!
  tag: Tag!
}

type VideoDeleteTagHistoryItem implements VideoHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  video: Video!
  tag: Tag!
}

type VideoAddNicovideoVideoSourceHistoryItem implements VideoHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  video: Video!

  source: NicovideoVideoSource!
}

input GetVideosInput {
  limit: Int = 10
  skip: Int = 0
  order: GetVideosInputOrder = { createdAt: DESC }
}

input GetVideosInputOrder {
  updatedAt: SortOrder
  createdAt: SortOrder
}

type VideoCollection {
  nodes: [Video!]!
}

input VideoSimilarVideosInput {
  limit: Int = 10
}

type VideoSimilarVideosPayload {
  items: [VideoSimilarVideoItem!]!
}

type VideoSimilarVideoItem {
  video: Video!
  score: Float!
}

type Tag {
  id: ID!
  type: TagType! @deprecated
  pseudoType: PseudoTagType!
  name: String!
  names: [TagName!]!

  taggedVideos: [Video!]!
  history(input: TagHistoryInput!): TagHistoryCollection!

  explicitParent: Tag
  parents(meaningless: Boolean): [TagParent!]!
  meaningless: Boolean!

  canTagTo(id: ID!): Boolean!
}

input TagHistoryInput {
  skip: Int = 0
  limit: Int = 10
  order: TagHistoryOrder = { createdAt: DESC }
}

input TagHistoryOrder {
  createdAt: SortOrder
}

type TagHistoryCollection {
  nodes: [VideoHistoryItem!]!
}

type TagCollection {
  nodes: [Tag!]!
}

input GetTagsInput {
  limit: Int
  skip: Int
  order: GetTagsInputOrder = { updatedAt: DESC }
}

input GetTagsInputOrder {
  updatedAt: SortOrder
  createdAt: SortOrder
}

type TagName {
  name: String!
  primary: Boolean!
}

type TagParent {
  tag: Tag!
  explicit: Boolean!
}

enum TagType {
  COPYRIGHT
  MATERIAL
  MUSIC
  SERIES
  IMAGE
  TACTICS
  CLASS
  EVENT
}

enum PseudoTagType {
  "曲"
  MUSIC
  "作品名"
  COPYRIGHT
  "キャラクター"
  CHARACTER
  "特徴的なセリフなど"
  PHRASE
  "シリーズ"
  SERIES
  "戦法"
  TACTICS
  "動画そのものに対しての性質，作風など"
  STYLE
  "動画の内容に依らない情報，分類など"
  CLASS
  "合作などのイベント"
  EVENT
  "2つ以上のタイプが算出された場合"
  SUBTLE
  "タイプを算出できなかった場合"
  UNKNOWN
}

interface TagHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
}

type TagRegisterHistoryItem implements TagHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  tag: Tag!
}

type TagAddNameHistoryItem implements TagHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  tag: Tag!
  name: String!
}

type TagDeleteNameHistoryItem implements TagHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  tag: Tag!
  name: String!
}

type TagChangePrimaryNameHistoryItem implements TagHistoryItem {
  id: ID!
  user: User!
  createdAt: DateTime!
  tag: Tag!
  from: String
  to: String!
}

input SearchVideoInput {
  query: String!
  limit: Int = 10
  skip: Int = 0
}

type SearchVideosPayload {
  # count: Int!
  result: [SearchVideosResultItem!]!
}

type SearchVideosResultItem {
  matchedTitle: String!
  video: Video!
}

input SearchTagInput {
  query: String!
  limit: Int = 10
  skip: Int = 0
}

type SearchTagsPayload {
  # count: Int!
  result: [SearchTagsResultItem!]!
}

type SearchTagsResultItem {
  matchedName: String!
  tag: Tag!
}

type User {
  id: ID!
  name: String!
  displayName: String!
  icon: String!

  favorites: Mylist!
  mylists(input: UserMylistsInput!): UserMylistsConnection!
}

input UserMylistsInput {
  limit: Int
  skip: Int
  order: UserMylistsInputOrder = { createdAt: ASC }
  range: [MylistShareRange!] = [PUBLIC]
}

input UserMylistsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

type UserMylistsConnection {
  nodes: [Mylist!]!
}

input RegisterTagInput {
  primaryName: String!
  extraNames: [String!] = []

  explicitParent: ID
  implicitParents: [ID!] = []

  meaningless: Boolean = false
}

type RegisterTagPayload {
  tag: Tag!
}

input RegisterVideoInput {
  primaryTitle: String!
  extraTitles: [String!]
  tags: [ID!]!
  primaryThumbnail: String!
  sources: [RegisterVideoInputSource!]!
}

enum RegisterVideoInputSourceType {
  NICOVIDEO
  # YOUTUBE
}

input RegisterVideoInputSource {
  type: RegisterVideoInputSourceType!
  sourceId: String!
}

type RegisterVideoPayload {
  video: Video!
}

input TagVideoInput {
  videoId: ID!
  tagId: ID!
}

type TagVideoPayload {
  video: Video!
  tag: Tag!
  # history: VideoAddTagHistoryItem!
}

input UntagVideoInput {
  videoId: ID!
  tagId: ID!
}

type UntagVideoPayload {
  video: Video!
  tag: Tag!
  # history: VideoDeleteTagHistoryItem!
}

type Mylist {
  id: ID!
  title: String!
  holder: User!
  range: MylistShareRange!
  createdAt: DateTime!
  updatedAt: DateTime!

  registrations(input: MylistRegistrationsInput!): MylistRegistrationCollection!

  """
  マイリストの中にビデオが追加されているか．
  """
  isIncludesVideo(id: ID!): Boolean!

  recommendedVideos(input: MylistRecommendedVideosInput): MylistRecommendedVideosPayload!

  includeTags(input: MylistIncludeTagsInput!): MylistIncludeTagsPayload!
}

enum MylistShareRange {
  PUBLIC
  KNOW_LINK
  PRIVATE
}

type MylistRegistration {
  id: ID!
  video: Video!
  mylist: Mylist!

  createdAt: DateTime!
  updatedAt: DateTime!
  note: String
}

type MylistRegistrationCollection {
  nodes: [MylistRegistration!]!
}

input MylistRegistrationsInput {
  limit: Int
  skip: Int
  order: MylistRegistrationsInputOrder = { registeredAt: ASC }
}

input MylistRegistrationsInputOrder {
  createdAt: SortOrder
  updatedAt: SortOrder
}

input MylistRecommendedVideosInput {
  limit: Int = 10
}

type MylistRecommendedVideosPayload {
  items: [MylistRecommendedVideosItem!]!
}

type MylistRecommendedVideosItem {
  video: Video!
  score: Float!
}

input MylistIncludeTagsInput {
  limit: Int = 10
}

type MylistIncludeTagsPayload {
  items: [MylistIncludeTagsItem!]!
}

type MylistIncludeTagsItem {
  tag: Tag!
  count: Int!
}

input CreateMylistInput {
  title: String!
  range: MylistShareRange!
}

type CreateMylistPayload {
  mylist: Mylist!
}

input LikeVideoInput {
  videoId: ID!
}

type LikeVideoPayload {
  registration: MylistRegistration!
}

input UndoLikeVideoInput {
  videoId: ID!
}

type UndoLikeVideoPayload {
  video: Video!
  mylist: Mylist!
}

input AddVideoToMylistInput {
  videoId: ID!
  mylistId: ID!
  note: String
}

type AddVideoToMylistPayload {
  registration: MylistRegistration!
}

input RemoveVideoFromMylistInput {
  videoId: ID!
  mylistId: ID!
}

type RemoveVideoFromMylistPayload {
  video: Video!
  mylist: Mylist!
}
